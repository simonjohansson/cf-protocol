// Code generated by counterfeiter. DO NOT EDIT.
package commandfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/cli/command"
	"code.cloudfoundry.org/cli/util/configv3"
)

type FakeConfig struct {
	AccessTokenStub        func() string
	accessTokenMutex       sync.RWMutex
	accessTokenArgsForCall []struct{}
	accessTokenReturns     struct {
		result1 string
	}
	accessTokenReturnsOnCall map[int]struct {
		result1 string
	}
	AddPluginStub        func(configv3.Plugin)
	addPluginMutex       sync.RWMutex
	addPluginArgsForCall []struct {
		arg1 configv3.Plugin
	}
	AddPluginRepositoryStub        func(name string, url string)
	addPluginRepositoryMutex       sync.RWMutex
	addPluginRepositoryArgsForCall []struct {
		name string
		url  string
	}
	APIVersionStub        func() string
	aPIVersionMutex       sync.RWMutex
	aPIVersionArgsForCall []struct{}
	aPIVersionReturns     struct {
		result1 string
	}
	aPIVersionReturnsOnCall map[int]struct {
		result1 string
	}
	BinaryNameStub        func() string
	binaryNameMutex       sync.RWMutex
	binaryNameArgsForCall []struct{}
	binaryNameReturns     struct {
		result1 string
	}
	binaryNameReturnsOnCall map[int]struct {
		result1 string
	}
	BinaryVersionStub        func() string
	binaryVersionMutex       sync.RWMutex
	binaryVersionArgsForCall []struct{}
	binaryVersionReturns     struct {
		result1 string
	}
	binaryVersionReturnsOnCall map[int]struct {
		result1 string
	}
	ColorEnabledStub        func() configv3.ColorSetting
	colorEnabledMutex       sync.RWMutex
	colorEnabledArgsForCall []struct{}
	colorEnabledReturns     struct {
		result1 configv3.ColorSetting
	}
	colorEnabledReturnsOnCall map[int]struct {
		result1 configv3.ColorSetting
	}
	CurrentUserStub        func() (configv3.User, error)
	currentUserMutex       sync.RWMutex
	currentUserArgsForCall []struct{}
	currentUserReturns     struct {
		result1 configv3.User
		result2 error
	}
	currentUserReturnsOnCall map[int]struct {
		result1 configv3.User
		result2 error
	}
	DialTimeoutStub        func() time.Duration
	dialTimeoutMutex       sync.RWMutex
	dialTimeoutArgsForCall []struct{}
	dialTimeoutReturns     struct {
		result1 time.Duration
	}
	dialTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	DockerPasswordStub        func() string
	dockerPasswordMutex       sync.RWMutex
	dockerPasswordArgsForCall []struct{}
	dockerPasswordReturns     struct {
		result1 string
	}
	dockerPasswordReturnsOnCall map[int]struct {
		result1 string
	}
	ExperimentalStub        func() bool
	experimentalMutex       sync.RWMutex
	experimentalArgsForCall []struct{}
	experimentalReturns     struct {
		result1 bool
	}
	experimentalReturnsOnCall map[int]struct {
		result1 bool
	}
	GetPluginStub        func(pluginName string) (configv3.Plugin, bool)
	getPluginMutex       sync.RWMutex
	getPluginArgsForCall []struct {
		pluginName string
	}
	getPluginReturns struct {
		result1 configv3.Plugin
		result2 bool
	}
	getPluginReturnsOnCall map[int]struct {
		result1 configv3.Plugin
		result2 bool
	}
	GetPluginCaseInsensitiveStub        func(pluginName string) (configv3.Plugin, bool)
	getPluginCaseInsensitiveMutex       sync.RWMutex
	getPluginCaseInsensitiveArgsForCall []struct {
		pluginName string
	}
	getPluginCaseInsensitiveReturns struct {
		result1 configv3.Plugin
		result2 bool
	}
	getPluginCaseInsensitiveReturnsOnCall map[int]struct {
		result1 configv3.Plugin
		result2 bool
	}
	HasTargetedOrganizationStub        func() bool
	hasTargetedOrganizationMutex       sync.RWMutex
	hasTargetedOrganizationArgsForCall []struct{}
	hasTargetedOrganizationReturns     struct {
		result1 bool
	}
	hasTargetedOrganizationReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedSpaceStub        func() bool
	hasTargetedSpaceMutex       sync.RWMutex
	hasTargetedSpaceArgsForCall []struct{}
	hasTargetedSpaceReturns     struct {
		result1 bool
	}
	hasTargetedSpaceReturnsOnCall map[int]struct {
		result1 bool
	}
	LocaleStub        func() string
	localeMutex       sync.RWMutex
	localeArgsForCall []struct{}
	localeReturns     struct {
		result1 string
	}
	localeReturnsOnCall map[int]struct {
		result1 string
	}
	MinCLIVersionStub        func() string
	minCLIVersionMutex       sync.RWMutex
	minCLIVersionArgsForCall []struct{}
	minCLIVersionReturns     struct {
		result1 string
	}
	minCLIVersionReturnsOnCall map[int]struct {
		result1 string
	}
	NOAARequestRetryCountStub        func() int
	nOAARequestRetryCountMutex       sync.RWMutex
	nOAARequestRetryCountArgsForCall []struct{}
	nOAARequestRetryCountReturns     struct {
		result1 int
	}
	nOAARequestRetryCountReturnsOnCall map[int]struct {
		result1 int
	}
	OverallPollingTimeoutStub        func() time.Duration
	overallPollingTimeoutMutex       sync.RWMutex
	overallPollingTimeoutArgsForCall []struct{}
	overallPollingTimeoutReturns     struct {
		result1 time.Duration
	}
	overallPollingTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	PluginHomeStub        func() string
	pluginHomeMutex       sync.RWMutex
	pluginHomeArgsForCall []struct{}
	pluginHomeReturns     struct {
		result1 string
	}
	pluginHomeReturnsOnCall map[int]struct {
		result1 string
	}
	PluginRepositoriesStub        func() []configv3.PluginRepository
	pluginRepositoriesMutex       sync.RWMutex
	pluginRepositoriesArgsForCall []struct{}
	pluginRepositoriesReturns     struct {
		result1 []configv3.PluginRepository
	}
	pluginRepositoriesReturnsOnCall map[int]struct {
		result1 []configv3.PluginRepository
	}
	PluginsStub        func() []configv3.Plugin
	pluginsMutex       sync.RWMutex
	pluginsArgsForCall []struct{}
	pluginsReturns     struct {
		result1 []configv3.Plugin
	}
	pluginsReturnsOnCall map[int]struct {
		result1 []configv3.Plugin
	}
	PollingIntervalStub        func() time.Duration
	pollingIntervalMutex       sync.RWMutex
	pollingIntervalArgsForCall []struct{}
	pollingIntervalReturns     struct {
		result1 time.Duration
	}
	pollingIntervalReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	RefreshTokenStub        func() string
	refreshTokenMutex       sync.RWMutex
	refreshTokenArgsForCall []struct{}
	refreshTokenReturns     struct {
		result1 string
	}
	refreshTokenReturnsOnCall map[int]struct {
		result1 string
	}
	RemovePluginStub        func(string)
	removePluginMutex       sync.RWMutex
	removePluginArgsForCall []struct {
		arg1 string
	}
	RequestRetryCountStub        func() int
	requestRetryCountMutex       sync.RWMutex
	requestRetryCountArgsForCall []struct{}
	requestRetryCountReturns     struct {
		result1 int
	}
	requestRetryCountReturnsOnCall map[int]struct {
		result1 int
	}
	SetAccessTokenStub        func(token string)
	setAccessTokenMutex       sync.RWMutex
	setAccessTokenArgsForCall []struct {
		token string
	}
	SetOrganizationInformationStub        func(guid string, name string)
	setOrganizationInformationMutex       sync.RWMutex
	setOrganizationInformationArgsForCall []struct {
		guid string
		name string
	}
	SetRefreshTokenStub        func(token string)
	setRefreshTokenMutex       sync.RWMutex
	setRefreshTokenArgsForCall []struct {
		token string
	}
	SetSpaceInformationStub        func(guid string, name string, allowSSH bool)
	setSpaceInformationMutex       sync.RWMutex
	setSpaceInformationArgsForCall []struct {
		guid     string
		name     string
		allowSSH bool
	}
	SetTargetInformationStub        func(api string, apiVersion string, auth string, minCLIVersion string, doppler string, routing string, skipSSLValidation bool)
	setTargetInformationMutex       sync.RWMutex
	setTargetInformationArgsForCall []struct {
		api               string
		apiVersion        string
		auth              string
		minCLIVersion     string
		doppler           string
		routing           string
		skipSSLValidation bool
	}
	SetTokenInformationStub        func(accessToken string, refreshToken string, sshOAuthClient string)
	setTokenInformationMutex       sync.RWMutex
	setTokenInformationArgsForCall []struct {
		accessToken    string
		refreshToken   string
		sshOAuthClient string
	}
	SetUAAEndpointStub        func(uaaEndpoint string)
	setUAAEndpointMutex       sync.RWMutex
	setUAAEndpointArgsForCall []struct {
		uaaEndpoint string
	}
	SkipSSLValidationStub        func() bool
	skipSSLValidationMutex       sync.RWMutex
	skipSSLValidationArgsForCall []struct{}
	skipSSLValidationReturns     struct {
		result1 bool
	}
	skipSSLValidationReturnsOnCall map[int]struct {
		result1 bool
	}
	SSHOAuthClientStub        func() string
	sSHOAuthClientMutex       sync.RWMutex
	sSHOAuthClientArgsForCall []struct{}
	sSHOAuthClientReturns     struct {
		result1 string
	}
	sSHOAuthClientReturnsOnCall map[int]struct {
		result1 string
	}
	StagingTimeoutStub        func() time.Duration
	stagingTimeoutMutex       sync.RWMutex
	stagingTimeoutArgsForCall []struct{}
	stagingTimeoutReturns     struct {
		result1 time.Duration
	}
	stagingTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	StartupTimeoutStub        func() time.Duration
	startupTimeoutMutex       sync.RWMutex
	startupTimeoutArgsForCall []struct{}
	startupTimeoutReturns     struct {
		result1 time.Duration
	}
	startupTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	TargetStub        func() string
	targetMutex       sync.RWMutex
	targetArgsForCall []struct{}
	targetReturns     struct {
		result1 string
	}
	targetReturnsOnCall map[int]struct {
		result1 string
	}
	TargetedOrganizationStub        func() configv3.Organization
	targetedOrganizationMutex       sync.RWMutex
	targetedOrganizationArgsForCall []struct{}
	targetedOrganizationReturns     struct {
		result1 configv3.Organization
	}
	targetedOrganizationReturnsOnCall map[int]struct {
		result1 configv3.Organization
	}
	TargetedSpaceStub        func() configv3.Space
	targetedSpaceMutex       sync.RWMutex
	targetedSpaceArgsForCall []struct{}
	targetedSpaceReturns     struct {
		result1 configv3.Space
	}
	targetedSpaceReturnsOnCall map[int]struct {
		result1 configv3.Space
	}
	UAAOAuthClientStub        func() string
	uAAOAuthClientMutex       sync.RWMutex
	uAAOAuthClientArgsForCall []struct{}
	uAAOAuthClientReturns     struct {
		result1 string
	}
	uAAOAuthClientReturnsOnCall map[int]struct {
		result1 string
	}
	UAAOAuthClientSecretStub        func() string
	uAAOAuthClientSecretMutex       sync.RWMutex
	uAAOAuthClientSecretArgsForCall []struct{}
	uAAOAuthClientSecretReturns     struct {
		result1 string
	}
	uAAOAuthClientSecretReturnsOnCall map[int]struct {
		result1 string
	}
	UnsetOrganizationInformationStub        func()
	unsetOrganizationInformationMutex       sync.RWMutex
	unsetOrganizationInformationArgsForCall []struct{}
	UnsetSpaceInformationStub               func()
	unsetSpaceInformationMutex              sync.RWMutex
	unsetSpaceInformationArgsForCall        []struct{}
	VerboseStub                             func() (bool, []string)
	verboseMutex                            sync.RWMutex
	verboseArgsForCall                      []struct{}
	verboseReturns                          struct {
		result1 bool
		result2 []string
	}
	verboseReturnsOnCall map[int]struct {
		result1 bool
		result2 []string
	}
	WritePluginConfigStub        func() error
	writePluginConfigMutex       sync.RWMutex
	writePluginConfigArgsForCall []struct{}
	writePluginConfigReturns     struct {
		result1 error
	}
	writePluginConfigReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConfig) AccessToken() string {
	fake.accessTokenMutex.Lock()
	ret, specificReturn := fake.accessTokenReturnsOnCall[len(fake.accessTokenArgsForCall)]
	fake.accessTokenArgsForCall = append(fake.accessTokenArgsForCall, struct{}{})
	fake.recordInvocation("AccessToken", []interface{}{})
	fake.accessTokenMutex.Unlock()
	if fake.AccessTokenStub != nil {
		return fake.AccessTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.accessTokenReturns.result1
}

func (fake *FakeConfig) AccessTokenCallCount() int {
	fake.accessTokenMutex.RLock()
	defer fake.accessTokenMutex.RUnlock()
	return len(fake.accessTokenArgsForCall)
}

func (fake *FakeConfig) AccessTokenReturns(result1 string) {
	fake.AccessTokenStub = nil
	fake.accessTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) AccessTokenReturnsOnCall(i int, result1 string) {
	fake.AccessTokenStub = nil
	if fake.accessTokenReturnsOnCall == nil {
		fake.accessTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.accessTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) AddPlugin(arg1 configv3.Plugin) {
	fake.addPluginMutex.Lock()
	fake.addPluginArgsForCall = append(fake.addPluginArgsForCall, struct {
		arg1 configv3.Plugin
	}{arg1})
	fake.recordInvocation("AddPlugin", []interface{}{arg1})
	fake.addPluginMutex.Unlock()
	if fake.AddPluginStub != nil {
		fake.AddPluginStub(arg1)
	}
}

func (fake *FakeConfig) AddPluginCallCount() int {
	fake.addPluginMutex.RLock()
	defer fake.addPluginMutex.RUnlock()
	return len(fake.addPluginArgsForCall)
}

func (fake *FakeConfig) AddPluginArgsForCall(i int) configv3.Plugin {
	fake.addPluginMutex.RLock()
	defer fake.addPluginMutex.RUnlock()
	return fake.addPluginArgsForCall[i].arg1
}

func (fake *FakeConfig) AddPluginRepository(name string, url string) {
	fake.addPluginRepositoryMutex.Lock()
	fake.addPluginRepositoryArgsForCall = append(fake.addPluginRepositoryArgsForCall, struct {
		name string
		url  string
	}{name, url})
	fake.recordInvocation("AddPluginRepository", []interface{}{name, url})
	fake.addPluginRepositoryMutex.Unlock()
	if fake.AddPluginRepositoryStub != nil {
		fake.AddPluginRepositoryStub(name, url)
	}
}

func (fake *FakeConfig) AddPluginRepositoryCallCount() int {
	fake.addPluginRepositoryMutex.RLock()
	defer fake.addPluginRepositoryMutex.RUnlock()
	return len(fake.addPluginRepositoryArgsForCall)
}

func (fake *FakeConfig) AddPluginRepositoryArgsForCall(i int) (string, string) {
	fake.addPluginRepositoryMutex.RLock()
	defer fake.addPluginRepositoryMutex.RUnlock()
	return fake.addPluginRepositoryArgsForCall[i].name, fake.addPluginRepositoryArgsForCall[i].url
}

func (fake *FakeConfig) APIVersion() string {
	fake.aPIVersionMutex.Lock()
	ret, specificReturn := fake.aPIVersionReturnsOnCall[len(fake.aPIVersionArgsForCall)]
	fake.aPIVersionArgsForCall = append(fake.aPIVersionArgsForCall, struct{}{})
	fake.recordInvocation("APIVersion", []interface{}{})
	fake.aPIVersionMutex.Unlock()
	if fake.APIVersionStub != nil {
		return fake.APIVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.aPIVersionReturns.result1
}

func (fake *FakeConfig) APIVersionCallCount() int {
	fake.aPIVersionMutex.RLock()
	defer fake.aPIVersionMutex.RUnlock()
	return len(fake.aPIVersionArgsForCall)
}

func (fake *FakeConfig) APIVersionReturns(result1 string) {
	fake.APIVersionStub = nil
	fake.aPIVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) APIVersionReturnsOnCall(i int, result1 string) {
	fake.APIVersionStub = nil
	if fake.aPIVersionReturnsOnCall == nil {
		fake.aPIVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.aPIVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryName() string {
	fake.binaryNameMutex.Lock()
	ret, specificReturn := fake.binaryNameReturnsOnCall[len(fake.binaryNameArgsForCall)]
	fake.binaryNameArgsForCall = append(fake.binaryNameArgsForCall, struct{}{})
	fake.recordInvocation("BinaryName", []interface{}{})
	fake.binaryNameMutex.Unlock()
	if fake.BinaryNameStub != nil {
		return fake.BinaryNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.binaryNameReturns.result1
}

func (fake *FakeConfig) BinaryNameCallCount() int {
	fake.binaryNameMutex.RLock()
	defer fake.binaryNameMutex.RUnlock()
	return len(fake.binaryNameArgsForCall)
}

func (fake *FakeConfig) BinaryNameReturns(result1 string) {
	fake.BinaryNameStub = nil
	fake.binaryNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryNameReturnsOnCall(i int, result1 string) {
	fake.BinaryNameStub = nil
	if fake.binaryNameReturnsOnCall == nil {
		fake.binaryNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.binaryNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryVersion() string {
	fake.binaryVersionMutex.Lock()
	ret, specificReturn := fake.binaryVersionReturnsOnCall[len(fake.binaryVersionArgsForCall)]
	fake.binaryVersionArgsForCall = append(fake.binaryVersionArgsForCall, struct{}{})
	fake.recordInvocation("BinaryVersion", []interface{}{})
	fake.binaryVersionMutex.Unlock()
	if fake.BinaryVersionStub != nil {
		return fake.BinaryVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.binaryVersionReturns.result1
}

func (fake *FakeConfig) BinaryVersionCallCount() int {
	fake.binaryVersionMutex.RLock()
	defer fake.binaryVersionMutex.RUnlock()
	return len(fake.binaryVersionArgsForCall)
}

func (fake *FakeConfig) BinaryVersionReturns(result1 string) {
	fake.BinaryVersionStub = nil
	fake.binaryVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) BinaryVersionReturnsOnCall(i int, result1 string) {
	fake.BinaryVersionStub = nil
	if fake.binaryVersionReturnsOnCall == nil {
		fake.binaryVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.binaryVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) ColorEnabled() configv3.ColorSetting {
	fake.colorEnabledMutex.Lock()
	ret, specificReturn := fake.colorEnabledReturnsOnCall[len(fake.colorEnabledArgsForCall)]
	fake.colorEnabledArgsForCall = append(fake.colorEnabledArgsForCall, struct{}{})
	fake.recordInvocation("ColorEnabled", []interface{}{})
	fake.colorEnabledMutex.Unlock()
	if fake.ColorEnabledStub != nil {
		return fake.ColorEnabledStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.colorEnabledReturns.result1
}

func (fake *FakeConfig) ColorEnabledCallCount() int {
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	return len(fake.colorEnabledArgsForCall)
}

func (fake *FakeConfig) ColorEnabledReturns(result1 configv3.ColorSetting) {
	fake.ColorEnabledStub = nil
	fake.colorEnabledReturns = struct {
		result1 configv3.ColorSetting
	}{result1}
}

func (fake *FakeConfig) ColorEnabledReturnsOnCall(i int, result1 configv3.ColorSetting) {
	fake.ColorEnabledStub = nil
	if fake.colorEnabledReturnsOnCall == nil {
		fake.colorEnabledReturnsOnCall = make(map[int]struct {
			result1 configv3.ColorSetting
		})
	}
	fake.colorEnabledReturnsOnCall[i] = struct {
		result1 configv3.ColorSetting
	}{result1}
}

func (fake *FakeConfig) CurrentUser() (configv3.User, error) {
	fake.currentUserMutex.Lock()
	ret, specificReturn := fake.currentUserReturnsOnCall[len(fake.currentUserArgsForCall)]
	fake.currentUserArgsForCall = append(fake.currentUserArgsForCall, struct{}{})
	fake.recordInvocation("CurrentUser", []interface{}{})
	fake.currentUserMutex.Unlock()
	if fake.CurrentUserStub != nil {
		return fake.CurrentUserStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.currentUserReturns.result1, fake.currentUserReturns.result2
}

func (fake *FakeConfig) CurrentUserCallCount() int {
	fake.currentUserMutex.RLock()
	defer fake.currentUserMutex.RUnlock()
	return len(fake.currentUserArgsForCall)
}

func (fake *FakeConfig) CurrentUserReturns(result1 configv3.User, result2 error) {
	fake.CurrentUserStub = nil
	fake.currentUserReturns = struct {
		result1 configv3.User
		result2 error
	}{result1, result2}
}

func (fake *FakeConfig) CurrentUserReturnsOnCall(i int, result1 configv3.User, result2 error) {
	fake.CurrentUserStub = nil
	if fake.currentUserReturnsOnCall == nil {
		fake.currentUserReturnsOnCall = make(map[int]struct {
			result1 configv3.User
			result2 error
		})
	}
	fake.currentUserReturnsOnCall[i] = struct {
		result1 configv3.User
		result2 error
	}{result1, result2}
}

func (fake *FakeConfig) DialTimeout() time.Duration {
	fake.dialTimeoutMutex.Lock()
	ret, specificReturn := fake.dialTimeoutReturnsOnCall[len(fake.dialTimeoutArgsForCall)]
	fake.dialTimeoutArgsForCall = append(fake.dialTimeoutArgsForCall, struct{}{})
	fake.recordInvocation("DialTimeout", []interface{}{})
	fake.dialTimeoutMutex.Unlock()
	if fake.DialTimeoutStub != nil {
		return fake.DialTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dialTimeoutReturns.result1
}

func (fake *FakeConfig) DialTimeoutCallCount() int {
	fake.dialTimeoutMutex.RLock()
	defer fake.dialTimeoutMutex.RUnlock()
	return len(fake.dialTimeoutArgsForCall)
}

func (fake *FakeConfig) DialTimeoutReturns(result1 time.Duration) {
	fake.DialTimeoutStub = nil
	fake.dialTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) DialTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.DialTimeoutStub = nil
	if fake.dialTimeoutReturnsOnCall == nil {
		fake.dialTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.dialTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) DockerPassword() string {
	fake.dockerPasswordMutex.Lock()
	ret, specificReturn := fake.dockerPasswordReturnsOnCall[len(fake.dockerPasswordArgsForCall)]
	fake.dockerPasswordArgsForCall = append(fake.dockerPasswordArgsForCall, struct{}{})
	fake.recordInvocation("DockerPassword", []interface{}{})
	fake.dockerPasswordMutex.Unlock()
	if fake.DockerPasswordStub != nil {
		return fake.DockerPasswordStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.dockerPasswordReturns.result1
}

func (fake *FakeConfig) DockerPasswordCallCount() int {
	fake.dockerPasswordMutex.RLock()
	defer fake.dockerPasswordMutex.RUnlock()
	return len(fake.dockerPasswordArgsForCall)
}

func (fake *FakeConfig) DockerPasswordReturns(result1 string) {
	fake.DockerPasswordStub = nil
	fake.dockerPasswordReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) DockerPasswordReturnsOnCall(i int, result1 string) {
	fake.DockerPasswordStub = nil
	if fake.dockerPasswordReturnsOnCall == nil {
		fake.dockerPasswordReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.dockerPasswordReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) Experimental() bool {
	fake.experimentalMutex.Lock()
	ret, specificReturn := fake.experimentalReturnsOnCall[len(fake.experimentalArgsForCall)]
	fake.experimentalArgsForCall = append(fake.experimentalArgsForCall, struct{}{})
	fake.recordInvocation("Experimental", []interface{}{})
	fake.experimentalMutex.Unlock()
	if fake.ExperimentalStub != nil {
		return fake.ExperimentalStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.experimentalReturns.result1
}

func (fake *FakeConfig) ExperimentalCallCount() int {
	fake.experimentalMutex.RLock()
	defer fake.experimentalMutex.RUnlock()
	return len(fake.experimentalArgsForCall)
}

func (fake *FakeConfig) ExperimentalReturns(result1 bool) {
	fake.ExperimentalStub = nil
	fake.experimentalReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) ExperimentalReturnsOnCall(i int, result1 bool) {
	fake.ExperimentalStub = nil
	if fake.experimentalReturnsOnCall == nil {
		fake.experimentalReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.experimentalReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) GetPlugin(pluginName string) (configv3.Plugin, bool) {
	fake.getPluginMutex.Lock()
	ret, specificReturn := fake.getPluginReturnsOnCall[len(fake.getPluginArgsForCall)]
	fake.getPluginArgsForCall = append(fake.getPluginArgsForCall, struct {
		pluginName string
	}{pluginName})
	fake.recordInvocation("GetPlugin", []interface{}{pluginName})
	fake.getPluginMutex.Unlock()
	if fake.GetPluginStub != nil {
		return fake.GetPluginStub(pluginName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getPluginReturns.result1, fake.getPluginReturns.result2
}

func (fake *FakeConfig) GetPluginCallCount() int {
	fake.getPluginMutex.RLock()
	defer fake.getPluginMutex.RUnlock()
	return len(fake.getPluginArgsForCall)
}

func (fake *FakeConfig) GetPluginArgsForCall(i int) string {
	fake.getPluginMutex.RLock()
	defer fake.getPluginMutex.RUnlock()
	return fake.getPluginArgsForCall[i].pluginName
}

func (fake *FakeConfig) GetPluginReturns(result1 configv3.Plugin, result2 bool) {
	fake.GetPluginStub = nil
	fake.getPluginReturns = struct {
		result1 configv3.Plugin
		result2 bool
	}{result1, result2}
}

func (fake *FakeConfig) GetPluginReturnsOnCall(i int, result1 configv3.Plugin, result2 bool) {
	fake.GetPluginStub = nil
	if fake.getPluginReturnsOnCall == nil {
		fake.getPluginReturnsOnCall = make(map[int]struct {
			result1 configv3.Plugin
			result2 bool
		})
	}
	fake.getPluginReturnsOnCall[i] = struct {
		result1 configv3.Plugin
		result2 bool
	}{result1, result2}
}

func (fake *FakeConfig) GetPluginCaseInsensitive(pluginName string) (configv3.Plugin, bool) {
	fake.getPluginCaseInsensitiveMutex.Lock()
	ret, specificReturn := fake.getPluginCaseInsensitiveReturnsOnCall[len(fake.getPluginCaseInsensitiveArgsForCall)]
	fake.getPluginCaseInsensitiveArgsForCall = append(fake.getPluginCaseInsensitiveArgsForCall, struct {
		pluginName string
	}{pluginName})
	fake.recordInvocation("GetPluginCaseInsensitive", []interface{}{pluginName})
	fake.getPluginCaseInsensitiveMutex.Unlock()
	if fake.GetPluginCaseInsensitiveStub != nil {
		return fake.GetPluginCaseInsensitiveStub(pluginName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getPluginCaseInsensitiveReturns.result1, fake.getPluginCaseInsensitiveReturns.result2
}

func (fake *FakeConfig) GetPluginCaseInsensitiveCallCount() int {
	fake.getPluginCaseInsensitiveMutex.RLock()
	defer fake.getPluginCaseInsensitiveMutex.RUnlock()
	return len(fake.getPluginCaseInsensitiveArgsForCall)
}

func (fake *FakeConfig) GetPluginCaseInsensitiveArgsForCall(i int) string {
	fake.getPluginCaseInsensitiveMutex.RLock()
	defer fake.getPluginCaseInsensitiveMutex.RUnlock()
	return fake.getPluginCaseInsensitiveArgsForCall[i].pluginName
}

func (fake *FakeConfig) GetPluginCaseInsensitiveReturns(result1 configv3.Plugin, result2 bool) {
	fake.GetPluginCaseInsensitiveStub = nil
	fake.getPluginCaseInsensitiveReturns = struct {
		result1 configv3.Plugin
		result2 bool
	}{result1, result2}
}

func (fake *FakeConfig) GetPluginCaseInsensitiveReturnsOnCall(i int, result1 configv3.Plugin, result2 bool) {
	fake.GetPluginCaseInsensitiveStub = nil
	if fake.getPluginCaseInsensitiveReturnsOnCall == nil {
		fake.getPluginCaseInsensitiveReturnsOnCall = make(map[int]struct {
			result1 configv3.Plugin
			result2 bool
		})
	}
	fake.getPluginCaseInsensitiveReturnsOnCall[i] = struct {
		result1 configv3.Plugin
		result2 bool
	}{result1, result2}
}

func (fake *FakeConfig) HasTargetedOrganization() bool {
	fake.hasTargetedOrganizationMutex.Lock()
	ret, specificReturn := fake.hasTargetedOrganizationReturnsOnCall[len(fake.hasTargetedOrganizationArgsForCall)]
	fake.hasTargetedOrganizationArgsForCall = append(fake.hasTargetedOrganizationArgsForCall, struct{}{})
	fake.recordInvocation("HasTargetedOrganization", []interface{}{})
	fake.hasTargetedOrganizationMutex.Unlock()
	if fake.HasTargetedOrganizationStub != nil {
		return fake.HasTargetedOrganizationStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hasTargetedOrganizationReturns.result1
}

func (fake *FakeConfig) HasTargetedOrganizationCallCount() int {
	fake.hasTargetedOrganizationMutex.RLock()
	defer fake.hasTargetedOrganizationMutex.RUnlock()
	return len(fake.hasTargetedOrganizationArgsForCall)
}

func (fake *FakeConfig) HasTargetedOrganizationReturns(result1 bool) {
	fake.HasTargetedOrganizationStub = nil
	fake.hasTargetedOrganizationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) HasTargetedOrganizationReturnsOnCall(i int, result1 bool) {
	fake.HasTargetedOrganizationStub = nil
	if fake.hasTargetedOrganizationReturnsOnCall == nil {
		fake.hasTargetedOrganizationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedOrganizationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) HasTargetedSpace() bool {
	fake.hasTargetedSpaceMutex.Lock()
	ret, specificReturn := fake.hasTargetedSpaceReturnsOnCall[len(fake.hasTargetedSpaceArgsForCall)]
	fake.hasTargetedSpaceArgsForCall = append(fake.hasTargetedSpaceArgsForCall, struct{}{})
	fake.recordInvocation("HasTargetedSpace", []interface{}{})
	fake.hasTargetedSpaceMutex.Unlock()
	if fake.HasTargetedSpaceStub != nil {
		return fake.HasTargetedSpaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hasTargetedSpaceReturns.result1
}

func (fake *FakeConfig) HasTargetedSpaceCallCount() int {
	fake.hasTargetedSpaceMutex.RLock()
	defer fake.hasTargetedSpaceMutex.RUnlock()
	return len(fake.hasTargetedSpaceArgsForCall)
}

func (fake *FakeConfig) HasTargetedSpaceReturns(result1 bool) {
	fake.HasTargetedSpaceStub = nil
	fake.hasTargetedSpaceReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) HasTargetedSpaceReturnsOnCall(i int, result1 bool) {
	fake.HasTargetedSpaceStub = nil
	if fake.hasTargetedSpaceReturnsOnCall == nil {
		fake.hasTargetedSpaceReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedSpaceReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) Locale() string {
	fake.localeMutex.Lock()
	ret, specificReturn := fake.localeReturnsOnCall[len(fake.localeArgsForCall)]
	fake.localeArgsForCall = append(fake.localeArgsForCall, struct{}{})
	fake.recordInvocation("Locale", []interface{}{})
	fake.localeMutex.Unlock()
	if fake.LocaleStub != nil {
		return fake.LocaleStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.localeReturns.result1
}

func (fake *FakeConfig) LocaleCallCount() int {
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	return len(fake.localeArgsForCall)
}

func (fake *FakeConfig) LocaleReturns(result1 string) {
	fake.LocaleStub = nil
	fake.localeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) LocaleReturnsOnCall(i int, result1 string) {
	fake.LocaleStub = nil
	if fake.localeReturnsOnCall == nil {
		fake.localeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.localeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) MinCLIVersion() string {
	fake.minCLIVersionMutex.Lock()
	ret, specificReturn := fake.minCLIVersionReturnsOnCall[len(fake.minCLIVersionArgsForCall)]
	fake.minCLIVersionArgsForCall = append(fake.minCLIVersionArgsForCall, struct{}{})
	fake.recordInvocation("MinCLIVersion", []interface{}{})
	fake.minCLIVersionMutex.Unlock()
	if fake.MinCLIVersionStub != nil {
		return fake.MinCLIVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.minCLIVersionReturns.result1
}

func (fake *FakeConfig) MinCLIVersionCallCount() int {
	fake.minCLIVersionMutex.RLock()
	defer fake.minCLIVersionMutex.RUnlock()
	return len(fake.minCLIVersionArgsForCall)
}

func (fake *FakeConfig) MinCLIVersionReturns(result1 string) {
	fake.MinCLIVersionStub = nil
	fake.minCLIVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) MinCLIVersionReturnsOnCall(i int, result1 string) {
	fake.MinCLIVersionStub = nil
	if fake.minCLIVersionReturnsOnCall == nil {
		fake.minCLIVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.minCLIVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) NOAARequestRetryCount() int {
	fake.nOAARequestRetryCountMutex.Lock()
	ret, specificReturn := fake.nOAARequestRetryCountReturnsOnCall[len(fake.nOAARequestRetryCountArgsForCall)]
	fake.nOAARequestRetryCountArgsForCall = append(fake.nOAARequestRetryCountArgsForCall, struct{}{})
	fake.recordInvocation("NOAARequestRetryCount", []interface{}{})
	fake.nOAARequestRetryCountMutex.Unlock()
	if fake.NOAARequestRetryCountStub != nil {
		return fake.NOAARequestRetryCountStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nOAARequestRetryCountReturns.result1
}

func (fake *FakeConfig) NOAARequestRetryCountCallCount() int {
	fake.nOAARequestRetryCountMutex.RLock()
	defer fake.nOAARequestRetryCountMutex.RUnlock()
	return len(fake.nOAARequestRetryCountArgsForCall)
}

func (fake *FakeConfig) NOAARequestRetryCountReturns(result1 int) {
	fake.NOAARequestRetryCountStub = nil
	fake.nOAARequestRetryCountReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) NOAARequestRetryCountReturnsOnCall(i int, result1 int) {
	fake.NOAARequestRetryCountStub = nil
	if fake.nOAARequestRetryCountReturnsOnCall == nil {
		fake.nOAARequestRetryCountReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.nOAARequestRetryCountReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) OverallPollingTimeout() time.Duration {
	fake.overallPollingTimeoutMutex.Lock()
	ret, specificReturn := fake.overallPollingTimeoutReturnsOnCall[len(fake.overallPollingTimeoutArgsForCall)]
	fake.overallPollingTimeoutArgsForCall = append(fake.overallPollingTimeoutArgsForCall, struct{}{})
	fake.recordInvocation("OverallPollingTimeout", []interface{}{})
	fake.overallPollingTimeoutMutex.Unlock()
	if fake.OverallPollingTimeoutStub != nil {
		return fake.OverallPollingTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.overallPollingTimeoutReturns.result1
}

func (fake *FakeConfig) OverallPollingTimeoutCallCount() int {
	fake.overallPollingTimeoutMutex.RLock()
	defer fake.overallPollingTimeoutMutex.RUnlock()
	return len(fake.overallPollingTimeoutArgsForCall)
}

func (fake *FakeConfig) OverallPollingTimeoutReturns(result1 time.Duration) {
	fake.OverallPollingTimeoutStub = nil
	fake.overallPollingTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) OverallPollingTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.OverallPollingTimeoutStub = nil
	if fake.overallPollingTimeoutReturnsOnCall == nil {
		fake.overallPollingTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.overallPollingTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) PluginHome() string {
	fake.pluginHomeMutex.Lock()
	ret, specificReturn := fake.pluginHomeReturnsOnCall[len(fake.pluginHomeArgsForCall)]
	fake.pluginHomeArgsForCall = append(fake.pluginHomeArgsForCall, struct{}{})
	fake.recordInvocation("PluginHome", []interface{}{})
	fake.pluginHomeMutex.Unlock()
	if fake.PluginHomeStub != nil {
		return fake.PluginHomeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginHomeReturns.result1
}

func (fake *FakeConfig) PluginHomeCallCount() int {
	fake.pluginHomeMutex.RLock()
	defer fake.pluginHomeMutex.RUnlock()
	return len(fake.pluginHomeArgsForCall)
}

func (fake *FakeConfig) PluginHomeReturns(result1 string) {
	fake.PluginHomeStub = nil
	fake.pluginHomeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) PluginHomeReturnsOnCall(i int, result1 string) {
	fake.PluginHomeStub = nil
	if fake.pluginHomeReturnsOnCall == nil {
		fake.pluginHomeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pluginHomeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) PluginRepositories() []configv3.PluginRepository {
	fake.pluginRepositoriesMutex.Lock()
	ret, specificReturn := fake.pluginRepositoriesReturnsOnCall[len(fake.pluginRepositoriesArgsForCall)]
	fake.pluginRepositoriesArgsForCall = append(fake.pluginRepositoriesArgsForCall, struct{}{})
	fake.recordInvocation("PluginRepositories", []interface{}{})
	fake.pluginRepositoriesMutex.Unlock()
	if fake.PluginRepositoriesStub != nil {
		return fake.PluginRepositoriesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginRepositoriesReturns.result1
}

func (fake *FakeConfig) PluginRepositoriesCallCount() int {
	fake.pluginRepositoriesMutex.RLock()
	defer fake.pluginRepositoriesMutex.RUnlock()
	return len(fake.pluginRepositoriesArgsForCall)
}

func (fake *FakeConfig) PluginRepositoriesReturns(result1 []configv3.PluginRepository) {
	fake.PluginRepositoriesStub = nil
	fake.pluginRepositoriesReturns = struct {
		result1 []configv3.PluginRepository
	}{result1}
}

func (fake *FakeConfig) PluginRepositoriesReturnsOnCall(i int, result1 []configv3.PluginRepository) {
	fake.PluginRepositoriesStub = nil
	if fake.pluginRepositoriesReturnsOnCall == nil {
		fake.pluginRepositoriesReturnsOnCall = make(map[int]struct {
			result1 []configv3.PluginRepository
		})
	}
	fake.pluginRepositoriesReturnsOnCall[i] = struct {
		result1 []configv3.PluginRepository
	}{result1}
}

func (fake *FakeConfig) Plugins() []configv3.Plugin {
	fake.pluginsMutex.Lock()
	ret, specificReturn := fake.pluginsReturnsOnCall[len(fake.pluginsArgsForCall)]
	fake.pluginsArgsForCall = append(fake.pluginsArgsForCall, struct{}{})
	fake.recordInvocation("Plugins", []interface{}{})
	fake.pluginsMutex.Unlock()
	if fake.PluginsStub != nil {
		return fake.PluginsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pluginsReturns.result1
}

func (fake *FakeConfig) PluginsCallCount() int {
	fake.pluginsMutex.RLock()
	defer fake.pluginsMutex.RUnlock()
	return len(fake.pluginsArgsForCall)
}

func (fake *FakeConfig) PluginsReturns(result1 []configv3.Plugin) {
	fake.PluginsStub = nil
	fake.pluginsReturns = struct {
		result1 []configv3.Plugin
	}{result1}
}

func (fake *FakeConfig) PluginsReturnsOnCall(i int, result1 []configv3.Plugin) {
	fake.PluginsStub = nil
	if fake.pluginsReturnsOnCall == nil {
		fake.pluginsReturnsOnCall = make(map[int]struct {
			result1 []configv3.Plugin
		})
	}
	fake.pluginsReturnsOnCall[i] = struct {
		result1 []configv3.Plugin
	}{result1}
}

func (fake *FakeConfig) PollingInterval() time.Duration {
	fake.pollingIntervalMutex.Lock()
	ret, specificReturn := fake.pollingIntervalReturnsOnCall[len(fake.pollingIntervalArgsForCall)]
	fake.pollingIntervalArgsForCall = append(fake.pollingIntervalArgsForCall, struct{}{})
	fake.recordInvocation("PollingInterval", []interface{}{})
	fake.pollingIntervalMutex.Unlock()
	if fake.PollingIntervalStub != nil {
		return fake.PollingIntervalStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pollingIntervalReturns.result1
}

func (fake *FakeConfig) PollingIntervalCallCount() int {
	fake.pollingIntervalMutex.RLock()
	defer fake.pollingIntervalMutex.RUnlock()
	return len(fake.pollingIntervalArgsForCall)
}

func (fake *FakeConfig) PollingIntervalReturns(result1 time.Duration) {
	fake.PollingIntervalStub = nil
	fake.pollingIntervalReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) PollingIntervalReturnsOnCall(i int, result1 time.Duration) {
	fake.PollingIntervalStub = nil
	if fake.pollingIntervalReturnsOnCall == nil {
		fake.pollingIntervalReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.pollingIntervalReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) RefreshToken() string {
	fake.refreshTokenMutex.Lock()
	ret, specificReturn := fake.refreshTokenReturnsOnCall[len(fake.refreshTokenArgsForCall)]
	fake.refreshTokenArgsForCall = append(fake.refreshTokenArgsForCall, struct{}{})
	fake.recordInvocation("RefreshToken", []interface{}{})
	fake.refreshTokenMutex.Unlock()
	if fake.RefreshTokenStub != nil {
		return fake.RefreshTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.refreshTokenReturns.result1
}

func (fake *FakeConfig) RefreshTokenCallCount() int {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	return len(fake.refreshTokenArgsForCall)
}

func (fake *FakeConfig) RefreshTokenReturns(result1 string) {
	fake.RefreshTokenStub = nil
	fake.refreshTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) RefreshTokenReturnsOnCall(i int, result1 string) {
	fake.RefreshTokenStub = nil
	if fake.refreshTokenReturnsOnCall == nil {
		fake.refreshTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.refreshTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) RemovePlugin(arg1 string) {
	fake.removePluginMutex.Lock()
	fake.removePluginArgsForCall = append(fake.removePluginArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RemovePlugin", []interface{}{arg1})
	fake.removePluginMutex.Unlock()
	if fake.RemovePluginStub != nil {
		fake.RemovePluginStub(arg1)
	}
}

func (fake *FakeConfig) RemovePluginCallCount() int {
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	return len(fake.removePluginArgsForCall)
}

func (fake *FakeConfig) RemovePluginArgsForCall(i int) string {
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	return fake.removePluginArgsForCall[i].arg1
}

func (fake *FakeConfig) RequestRetryCount() int {
	fake.requestRetryCountMutex.Lock()
	ret, specificReturn := fake.requestRetryCountReturnsOnCall[len(fake.requestRetryCountArgsForCall)]
	fake.requestRetryCountArgsForCall = append(fake.requestRetryCountArgsForCall, struct{}{})
	fake.recordInvocation("RequestRetryCount", []interface{}{})
	fake.requestRetryCountMutex.Unlock()
	if fake.RequestRetryCountStub != nil {
		return fake.RequestRetryCountStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.requestRetryCountReturns.result1
}

func (fake *FakeConfig) RequestRetryCountCallCount() int {
	fake.requestRetryCountMutex.RLock()
	defer fake.requestRetryCountMutex.RUnlock()
	return len(fake.requestRetryCountArgsForCall)
}

func (fake *FakeConfig) RequestRetryCountReturns(result1 int) {
	fake.RequestRetryCountStub = nil
	fake.requestRetryCountReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) RequestRetryCountReturnsOnCall(i int, result1 int) {
	fake.RequestRetryCountStub = nil
	if fake.requestRetryCountReturnsOnCall == nil {
		fake.requestRetryCountReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.requestRetryCountReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeConfig) SetAccessToken(token string) {
	fake.setAccessTokenMutex.Lock()
	fake.setAccessTokenArgsForCall = append(fake.setAccessTokenArgsForCall, struct {
		token string
	}{token})
	fake.recordInvocation("SetAccessToken", []interface{}{token})
	fake.setAccessTokenMutex.Unlock()
	if fake.SetAccessTokenStub != nil {
		fake.SetAccessTokenStub(token)
	}
}

func (fake *FakeConfig) SetAccessTokenCallCount() int {
	fake.setAccessTokenMutex.RLock()
	defer fake.setAccessTokenMutex.RUnlock()
	return len(fake.setAccessTokenArgsForCall)
}

func (fake *FakeConfig) SetAccessTokenArgsForCall(i int) string {
	fake.setAccessTokenMutex.RLock()
	defer fake.setAccessTokenMutex.RUnlock()
	return fake.setAccessTokenArgsForCall[i].token
}

func (fake *FakeConfig) SetOrganizationInformation(guid string, name string) {
	fake.setOrganizationInformationMutex.Lock()
	fake.setOrganizationInformationArgsForCall = append(fake.setOrganizationInformationArgsForCall, struct {
		guid string
		name string
	}{guid, name})
	fake.recordInvocation("SetOrganizationInformation", []interface{}{guid, name})
	fake.setOrganizationInformationMutex.Unlock()
	if fake.SetOrganizationInformationStub != nil {
		fake.SetOrganizationInformationStub(guid, name)
	}
}

func (fake *FakeConfig) SetOrganizationInformationCallCount() int {
	fake.setOrganizationInformationMutex.RLock()
	defer fake.setOrganizationInformationMutex.RUnlock()
	return len(fake.setOrganizationInformationArgsForCall)
}

func (fake *FakeConfig) SetOrganizationInformationArgsForCall(i int) (string, string) {
	fake.setOrganizationInformationMutex.RLock()
	defer fake.setOrganizationInformationMutex.RUnlock()
	return fake.setOrganizationInformationArgsForCall[i].guid, fake.setOrganizationInformationArgsForCall[i].name
}

func (fake *FakeConfig) SetRefreshToken(token string) {
	fake.setRefreshTokenMutex.Lock()
	fake.setRefreshTokenArgsForCall = append(fake.setRefreshTokenArgsForCall, struct {
		token string
	}{token})
	fake.recordInvocation("SetRefreshToken", []interface{}{token})
	fake.setRefreshTokenMutex.Unlock()
	if fake.SetRefreshTokenStub != nil {
		fake.SetRefreshTokenStub(token)
	}
}

func (fake *FakeConfig) SetRefreshTokenCallCount() int {
	fake.setRefreshTokenMutex.RLock()
	defer fake.setRefreshTokenMutex.RUnlock()
	return len(fake.setRefreshTokenArgsForCall)
}

func (fake *FakeConfig) SetRefreshTokenArgsForCall(i int) string {
	fake.setRefreshTokenMutex.RLock()
	defer fake.setRefreshTokenMutex.RUnlock()
	return fake.setRefreshTokenArgsForCall[i].token
}

func (fake *FakeConfig) SetSpaceInformation(guid string, name string, allowSSH bool) {
	fake.setSpaceInformationMutex.Lock()
	fake.setSpaceInformationArgsForCall = append(fake.setSpaceInformationArgsForCall, struct {
		guid     string
		name     string
		allowSSH bool
	}{guid, name, allowSSH})
	fake.recordInvocation("SetSpaceInformation", []interface{}{guid, name, allowSSH})
	fake.setSpaceInformationMutex.Unlock()
	if fake.SetSpaceInformationStub != nil {
		fake.SetSpaceInformationStub(guid, name, allowSSH)
	}
}

func (fake *FakeConfig) SetSpaceInformationCallCount() int {
	fake.setSpaceInformationMutex.RLock()
	defer fake.setSpaceInformationMutex.RUnlock()
	return len(fake.setSpaceInformationArgsForCall)
}

func (fake *FakeConfig) SetSpaceInformationArgsForCall(i int) (string, string, bool) {
	fake.setSpaceInformationMutex.RLock()
	defer fake.setSpaceInformationMutex.RUnlock()
	return fake.setSpaceInformationArgsForCall[i].guid, fake.setSpaceInformationArgsForCall[i].name, fake.setSpaceInformationArgsForCall[i].allowSSH
}

func (fake *FakeConfig) SetTargetInformation(api string, apiVersion string, auth string, minCLIVersion string, doppler string, routing string, skipSSLValidation bool) {
	fake.setTargetInformationMutex.Lock()
	fake.setTargetInformationArgsForCall = append(fake.setTargetInformationArgsForCall, struct {
		api               string
		apiVersion        string
		auth              string
		minCLIVersion     string
		doppler           string
		routing           string
		skipSSLValidation bool
	}{api, apiVersion, auth, minCLIVersion, doppler, routing, skipSSLValidation})
	fake.recordInvocation("SetTargetInformation", []interface{}{api, apiVersion, auth, minCLIVersion, doppler, routing, skipSSLValidation})
	fake.setTargetInformationMutex.Unlock()
	if fake.SetTargetInformationStub != nil {
		fake.SetTargetInformationStub(api, apiVersion, auth, minCLIVersion, doppler, routing, skipSSLValidation)
	}
}

func (fake *FakeConfig) SetTargetInformationCallCount() int {
	fake.setTargetInformationMutex.RLock()
	defer fake.setTargetInformationMutex.RUnlock()
	return len(fake.setTargetInformationArgsForCall)
}

func (fake *FakeConfig) SetTargetInformationArgsForCall(i int) (string, string, string, string, string, string, bool) {
	fake.setTargetInformationMutex.RLock()
	defer fake.setTargetInformationMutex.RUnlock()
	return fake.setTargetInformationArgsForCall[i].api, fake.setTargetInformationArgsForCall[i].apiVersion, fake.setTargetInformationArgsForCall[i].auth, fake.setTargetInformationArgsForCall[i].minCLIVersion, fake.setTargetInformationArgsForCall[i].doppler, fake.setTargetInformationArgsForCall[i].routing, fake.setTargetInformationArgsForCall[i].skipSSLValidation
}

func (fake *FakeConfig) SetTokenInformation(accessToken string, refreshToken string, sshOAuthClient string) {
	fake.setTokenInformationMutex.Lock()
	fake.setTokenInformationArgsForCall = append(fake.setTokenInformationArgsForCall, struct {
		accessToken    string
		refreshToken   string
		sshOAuthClient string
	}{accessToken, refreshToken, sshOAuthClient})
	fake.recordInvocation("SetTokenInformation", []interface{}{accessToken, refreshToken, sshOAuthClient})
	fake.setTokenInformationMutex.Unlock()
	if fake.SetTokenInformationStub != nil {
		fake.SetTokenInformationStub(accessToken, refreshToken, sshOAuthClient)
	}
}

func (fake *FakeConfig) SetTokenInformationCallCount() int {
	fake.setTokenInformationMutex.RLock()
	defer fake.setTokenInformationMutex.RUnlock()
	return len(fake.setTokenInformationArgsForCall)
}

func (fake *FakeConfig) SetTokenInformationArgsForCall(i int) (string, string, string) {
	fake.setTokenInformationMutex.RLock()
	defer fake.setTokenInformationMutex.RUnlock()
	return fake.setTokenInformationArgsForCall[i].accessToken, fake.setTokenInformationArgsForCall[i].refreshToken, fake.setTokenInformationArgsForCall[i].sshOAuthClient
}

func (fake *FakeConfig) SetUAAEndpoint(uaaEndpoint string) {
	fake.setUAAEndpointMutex.Lock()
	fake.setUAAEndpointArgsForCall = append(fake.setUAAEndpointArgsForCall, struct {
		uaaEndpoint string
	}{uaaEndpoint})
	fake.recordInvocation("SetUAAEndpoint", []interface{}{uaaEndpoint})
	fake.setUAAEndpointMutex.Unlock()
	if fake.SetUAAEndpointStub != nil {
		fake.SetUAAEndpointStub(uaaEndpoint)
	}
}

func (fake *FakeConfig) SetUAAEndpointCallCount() int {
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	return len(fake.setUAAEndpointArgsForCall)
}

func (fake *FakeConfig) SetUAAEndpointArgsForCall(i int) string {
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	return fake.setUAAEndpointArgsForCall[i].uaaEndpoint
}

func (fake *FakeConfig) SkipSSLValidation() bool {
	fake.skipSSLValidationMutex.Lock()
	ret, specificReturn := fake.skipSSLValidationReturnsOnCall[len(fake.skipSSLValidationArgsForCall)]
	fake.skipSSLValidationArgsForCall = append(fake.skipSSLValidationArgsForCall, struct{}{})
	fake.recordInvocation("SkipSSLValidation", []interface{}{})
	fake.skipSSLValidationMutex.Unlock()
	if fake.SkipSSLValidationStub != nil {
		return fake.SkipSSLValidationStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.skipSSLValidationReturns.result1
}

func (fake *FakeConfig) SkipSSLValidationCallCount() int {
	fake.skipSSLValidationMutex.RLock()
	defer fake.skipSSLValidationMutex.RUnlock()
	return len(fake.skipSSLValidationArgsForCall)
}

func (fake *FakeConfig) SkipSSLValidationReturns(result1 bool) {
	fake.SkipSSLValidationStub = nil
	fake.skipSSLValidationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) SkipSSLValidationReturnsOnCall(i int, result1 bool) {
	fake.SkipSSLValidationStub = nil
	if fake.skipSSLValidationReturnsOnCall == nil {
		fake.skipSSLValidationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.skipSSLValidationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConfig) SSHOAuthClient() string {
	fake.sSHOAuthClientMutex.Lock()
	ret, specificReturn := fake.sSHOAuthClientReturnsOnCall[len(fake.sSHOAuthClientArgsForCall)]
	fake.sSHOAuthClientArgsForCall = append(fake.sSHOAuthClientArgsForCall, struct{}{})
	fake.recordInvocation("SSHOAuthClient", []interface{}{})
	fake.sSHOAuthClientMutex.Unlock()
	if fake.SSHOAuthClientStub != nil {
		return fake.SSHOAuthClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.sSHOAuthClientReturns.result1
}

func (fake *FakeConfig) SSHOAuthClientCallCount() int {
	fake.sSHOAuthClientMutex.RLock()
	defer fake.sSHOAuthClientMutex.RUnlock()
	return len(fake.sSHOAuthClientArgsForCall)
}

func (fake *FakeConfig) SSHOAuthClientReturns(result1 string) {
	fake.SSHOAuthClientStub = nil
	fake.sSHOAuthClientReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) SSHOAuthClientReturnsOnCall(i int, result1 string) {
	fake.SSHOAuthClientStub = nil
	if fake.sSHOAuthClientReturnsOnCall == nil {
		fake.sSHOAuthClientReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.sSHOAuthClientReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) StagingTimeout() time.Duration {
	fake.stagingTimeoutMutex.Lock()
	ret, specificReturn := fake.stagingTimeoutReturnsOnCall[len(fake.stagingTimeoutArgsForCall)]
	fake.stagingTimeoutArgsForCall = append(fake.stagingTimeoutArgsForCall, struct{}{})
	fake.recordInvocation("StagingTimeout", []interface{}{})
	fake.stagingTimeoutMutex.Unlock()
	if fake.StagingTimeoutStub != nil {
		return fake.StagingTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stagingTimeoutReturns.result1
}

func (fake *FakeConfig) StagingTimeoutCallCount() int {
	fake.stagingTimeoutMutex.RLock()
	defer fake.stagingTimeoutMutex.RUnlock()
	return len(fake.stagingTimeoutArgsForCall)
}

func (fake *FakeConfig) StagingTimeoutReturns(result1 time.Duration) {
	fake.StagingTimeoutStub = nil
	fake.stagingTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) StagingTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.StagingTimeoutStub = nil
	if fake.stagingTimeoutReturnsOnCall == nil {
		fake.stagingTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.stagingTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) StartupTimeout() time.Duration {
	fake.startupTimeoutMutex.Lock()
	ret, specificReturn := fake.startupTimeoutReturnsOnCall[len(fake.startupTimeoutArgsForCall)]
	fake.startupTimeoutArgsForCall = append(fake.startupTimeoutArgsForCall, struct{}{})
	fake.recordInvocation("StartupTimeout", []interface{}{})
	fake.startupTimeoutMutex.Unlock()
	if fake.StartupTimeoutStub != nil {
		return fake.StartupTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startupTimeoutReturns.result1
}

func (fake *FakeConfig) StartupTimeoutCallCount() int {
	fake.startupTimeoutMutex.RLock()
	defer fake.startupTimeoutMutex.RUnlock()
	return len(fake.startupTimeoutArgsForCall)
}

func (fake *FakeConfig) StartupTimeoutReturns(result1 time.Duration) {
	fake.StartupTimeoutStub = nil
	fake.startupTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) StartupTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.StartupTimeoutStub = nil
	if fake.startupTimeoutReturnsOnCall == nil {
		fake.startupTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.startupTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *FakeConfig) Target() string {
	fake.targetMutex.Lock()
	ret, specificReturn := fake.targetReturnsOnCall[len(fake.targetArgsForCall)]
	fake.targetArgsForCall = append(fake.targetArgsForCall, struct{}{})
	fake.recordInvocation("Target", []interface{}{})
	fake.targetMutex.Unlock()
	if fake.TargetStub != nil {
		return fake.TargetStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.targetReturns.result1
}

func (fake *FakeConfig) TargetCallCount() int {
	fake.targetMutex.RLock()
	defer fake.targetMutex.RUnlock()
	return len(fake.targetArgsForCall)
}

func (fake *FakeConfig) TargetReturns(result1 string) {
	fake.TargetStub = nil
	fake.targetReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) TargetReturnsOnCall(i int, result1 string) {
	fake.TargetStub = nil
	if fake.targetReturnsOnCall == nil {
		fake.targetReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.targetReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) TargetedOrganization() configv3.Organization {
	fake.targetedOrganizationMutex.Lock()
	ret, specificReturn := fake.targetedOrganizationReturnsOnCall[len(fake.targetedOrganizationArgsForCall)]
	fake.targetedOrganizationArgsForCall = append(fake.targetedOrganizationArgsForCall, struct{}{})
	fake.recordInvocation("TargetedOrganization", []interface{}{})
	fake.targetedOrganizationMutex.Unlock()
	if fake.TargetedOrganizationStub != nil {
		return fake.TargetedOrganizationStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.targetedOrganizationReturns.result1
}

func (fake *FakeConfig) TargetedOrganizationCallCount() int {
	fake.targetedOrganizationMutex.RLock()
	defer fake.targetedOrganizationMutex.RUnlock()
	return len(fake.targetedOrganizationArgsForCall)
}

func (fake *FakeConfig) TargetedOrganizationReturns(result1 configv3.Organization) {
	fake.TargetedOrganizationStub = nil
	fake.targetedOrganizationReturns = struct {
		result1 configv3.Organization
	}{result1}
}

func (fake *FakeConfig) TargetedOrganizationReturnsOnCall(i int, result1 configv3.Organization) {
	fake.TargetedOrganizationStub = nil
	if fake.targetedOrganizationReturnsOnCall == nil {
		fake.targetedOrganizationReturnsOnCall = make(map[int]struct {
			result1 configv3.Organization
		})
	}
	fake.targetedOrganizationReturnsOnCall[i] = struct {
		result1 configv3.Organization
	}{result1}
}

func (fake *FakeConfig) TargetedSpace() configv3.Space {
	fake.targetedSpaceMutex.Lock()
	ret, specificReturn := fake.targetedSpaceReturnsOnCall[len(fake.targetedSpaceArgsForCall)]
	fake.targetedSpaceArgsForCall = append(fake.targetedSpaceArgsForCall, struct{}{})
	fake.recordInvocation("TargetedSpace", []interface{}{})
	fake.targetedSpaceMutex.Unlock()
	if fake.TargetedSpaceStub != nil {
		return fake.TargetedSpaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.targetedSpaceReturns.result1
}

func (fake *FakeConfig) TargetedSpaceCallCount() int {
	fake.targetedSpaceMutex.RLock()
	defer fake.targetedSpaceMutex.RUnlock()
	return len(fake.targetedSpaceArgsForCall)
}

func (fake *FakeConfig) TargetedSpaceReturns(result1 configv3.Space) {
	fake.TargetedSpaceStub = nil
	fake.targetedSpaceReturns = struct {
		result1 configv3.Space
	}{result1}
}

func (fake *FakeConfig) TargetedSpaceReturnsOnCall(i int, result1 configv3.Space) {
	fake.TargetedSpaceStub = nil
	if fake.targetedSpaceReturnsOnCall == nil {
		fake.targetedSpaceReturnsOnCall = make(map[int]struct {
			result1 configv3.Space
		})
	}
	fake.targetedSpaceReturnsOnCall[i] = struct {
		result1 configv3.Space
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClient() string {
	fake.uAAOAuthClientMutex.Lock()
	ret, specificReturn := fake.uAAOAuthClientReturnsOnCall[len(fake.uAAOAuthClientArgsForCall)]
	fake.uAAOAuthClientArgsForCall = append(fake.uAAOAuthClientArgsForCall, struct{}{})
	fake.recordInvocation("UAAOAuthClient", []interface{}{})
	fake.uAAOAuthClientMutex.Unlock()
	if fake.UAAOAuthClientStub != nil {
		return fake.UAAOAuthClientStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uAAOAuthClientReturns.result1
}

func (fake *FakeConfig) UAAOAuthClientCallCount() int {
	fake.uAAOAuthClientMutex.RLock()
	defer fake.uAAOAuthClientMutex.RUnlock()
	return len(fake.uAAOAuthClientArgsForCall)
}

func (fake *FakeConfig) UAAOAuthClientReturns(result1 string) {
	fake.UAAOAuthClientStub = nil
	fake.uAAOAuthClientReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientReturnsOnCall(i int, result1 string) {
	fake.UAAOAuthClientStub = nil
	if fake.uAAOAuthClientReturnsOnCall == nil {
		fake.uAAOAuthClientReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAOAuthClientReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientSecret() string {
	fake.uAAOAuthClientSecretMutex.Lock()
	ret, specificReturn := fake.uAAOAuthClientSecretReturnsOnCall[len(fake.uAAOAuthClientSecretArgsForCall)]
	fake.uAAOAuthClientSecretArgsForCall = append(fake.uAAOAuthClientSecretArgsForCall, struct{}{})
	fake.recordInvocation("UAAOAuthClientSecret", []interface{}{})
	fake.uAAOAuthClientSecretMutex.Unlock()
	if fake.UAAOAuthClientSecretStub != nil {
		return fake.UAAOAuthClientSecretStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.uAAOAuthClientSecretReturns.result1
}

func (fake *FakeConfig) UAAOAuthClientSecretCallCount() int {
	fake.uAAOAuthClientSecretMutex.RLock()
	defer fake.uAAOAuthClientSecretMutex.RUnlock()
	return len(fake.uAAOAuthClientSecretArgsForCall)
}

func (fake *FakeConfig) UAAOAuthClientSecretReturns(result1 string) {
	fake.UAAOAuthClientSecretStub = nil
	fake.uAAOAuthClientSecretReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UAAOAuthClientSecretReturnsOnCall(i int, result1 string) {
	fake.UAAOAuthClientSecretStub = nil
	if fake.uAAOAuthClientSecretReturnsOnCall == nil {
		fake.uAAOAuthClientSecretReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uAAOAuthClientSecretReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) UnsetOrganizationInformation() {
	fake.unsetOrganizationInformationMutex.Lock()
	fake.unsetOrganizationInformationArgsForCall = append(fake.unsetOrganizationInformationArgsForCall, struct{}{})
	fake.recordInvocation("UnsetOrganizationInformation", []interface{}{})
	fake.unsetOrganizationInformationMutex.Unlock()
	if fake.UnsetOrganizationInformationStub != nil {
		fake.UnsetOrganizationInformationStub()
	}
}

func (fake *FakeConfig) UnsetOrganizationInformationCallCount() int {
	fake.unsetOrganizationInformationMutex.RLock()
	defer fake.unsetOrganizationInformationMutex.RUnlock()
	return len(fake.unsetOrganizationInformationArgsForCall)
}

func (fake *FakeConfig) UnsetSpaceInformation() {
	fake.unsetSpaceInformationMutex.Lock()
	fake.unsetSpaceInformationArgsForCall = append(fake.unsetSpaceInformationArgsForCall, struct{}{})
	fake.recordInvocation("UnsetSpaceInformation", []interface{}{})
	fake.unsetSpaceInformationMutex.Unlock()
	if fake.UnsetSpaceInformationStub != nil {
		fake.UnsetSpaceInformationStub()
	}
}

func (fake *FakeConfig) UnsetSpaceInformationCallCount() int {
	fake.unsetSpaceInformationMutex.RLock()
	defer fake.unsetSpaceInformationMutex.RUnlock()
	return len(fake.unsetSpaceInformationArgsForCall)
}

func (fake *FakeConfig) Verbose() (bool, []string) {
	fake.verboseMutex.Lock()
	ret, specificReturn := fake.verboseReturnsOnCall[len(fake.verboseArgsForCall)]
	fake.verboseArgsForCall = append(fake.verboseArgsForCall, struct{}{})
	fake.recordInvocation("Verbose", []interface{}{})
	fake.verboseMutex.Unlock()
	if fake.VerboseStub != nil {
		return fake.VerboseStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.verboseReturns.result1, fake.verboseReturns.result2
}

func (fake *FakeConfig) VerboseCallCount() int {
	fake.verboseMutex.RLock()
	defer fake.verboseMutex.RUnlock()
	return len(fake.verboseArgsForCall)
}

func (fake *FakeConfig) VerboseReturns(result1 bool, result2 []string) {
	fake.VerboseStub = nil
	fake.verboseReturns = struct {
		result1 bool
		result2 []string
	}{result1, result2}
}

func (fake *FakeConfig) VerboseReturnsOnCall(i int, result1 bool, result2 []string) {
	fake.VerboseStub = nil
	if fake.verboseReturnsOnCall == nil {
		fake.verboseReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 []string
		})
	}
	fake.verboseReturnsOnCall[i] = struct {
		result1 bool
		result2 []string
	}{result1, result2}
}

func (fake *FakeConfig) WritePluginConfig() error {
	fake.writePluginConfigMutex.Lock()
	ret, specificReturn := fake.writePluginConfigReturnsOnCall[len(fake.writePluginConfigArgsForCall)]
	fake.writePluginConfigArgsForCall = append(fake.writePluginConfigArgsForCall, struct{}{})
	fake.recordInvocation("WritePluginConfig", []interface{}{})
	fake.writePluginConfigMutex.Unlock()
	if fake.WritePluginConfigStub != nil {
		return fake.WritePluginConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.writePluginConfigReturns.result1
}

func (fake *FakeConfig) WritePluginConfigCallCount() int {
	fake.writePluginConfigMutex.RLock()
	defer fake.writePluginConfigMutex.RUnlock()
	return len(fake.writePluginConfigArgsForCall)
}

func (fake *FakeConfig) WritePluginConfigReturns(result1 error) {
	fake.WritePluginConfigStub = nil
	fake.writePluginConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeConfig) WritePluginConfigReturnsOnCall(i int, result1 error) {
	fake.WritePluginConfigStub = nil
	if fake.writePluginConfigReturnsOnCall == nil {
		fake.writePluginConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.writePluginConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.accessTokenMutex.RLock()
	defer fake.accessTokenMutex.RUnlock()
	fake.addPluginMutex.RLock()
	defer fake.addPluginMutex.RUnlock()
	fake.addPluginRepositoryMutex.RLock()
	defer fake.addPluginRepositoryMutex.RUnlock()
	fake.aPIVersionMutex.RLock()
	defer fake.aPIVersionMutex.RUnlock()
	fake.binaryNameMutex.RLock()
	defer fake.binaryNameMutex.RUnlock()
	fake.binaryVersionMutex.RLock()
	defer fake.binaryVersionMutex.RUnlock()
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	fake.currentUserMutex.RLock()
	defer fake.currentUserMutex.RUnlock()
	fake.dialTimeoutMutex.RLock()
	defer fake.dialTimeoutMutex.RUnlock()
	fake.dockerPasswordMutex.RLock()
	defer fake.dockerPasswordMutex.RUnlock()
	fake.experimentalMutex.RLock()
	defer fake.experimentalMutex.RUnlock()
	fake.getPluginMutex.RLock()
	defer fake.getPluginMutex.RUnlock()
	fake.getPluginCaseInsensitiveMutex.RLock()
	defer fake.getPluginCaseInsensitiveMutex.RUnlock()
	fake.hasTargetedOrganizationMutex.RLock()
	defer fake.hasTargetedOrganizationMutex.RUnlock()
	fake.hasTargetedSpaceMutex.RLock()
	defer fake.hasTargetedSpaceMutex.RUnlock()
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	fake.minCLIVersionMutex.RLock()
	defer fake.minCLIVersionMutex.RUnlock()
	fake.nOAARequestRetryCountMutex.RLock()
	defer fake.nOAARequestRetryCountMutex.RUnlock()
	fake.overallPollingTimeoutMutex.RLock()
	defer fake.overallPollingTimeoutMutex.RUnlock()
	fake.pluginHomeMutex.RLock()
	defer fake.pluginHomeMutex.RUnlock()
	fake.pluginRepositoriesMutex.RLock()
	defer fake.pluginRepositoriesMutex.RUnlock()
	fake.pluginsMutex.RLock()
	defer fake.pluginsMutex.RUnlock()
	fake.pollingIntervalMutex.RLock()
	defer fake.pollingIntervalMutex.RUnlock()
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	fake.removePluginMutex.RLock()
	defer fake.removePluginMutex.RUnlock()
	fake.requestRetryCountMutex.RLock()
	defer fake.requestRetryCountMutex.RUnlock()
	fake.setAccessTokenMutex.RLock()
	defer fake.setAccessTokenMutex.RUnlock()
	fake.setOrganizationInformationMutex.RLock()
	defer fake.setOrganizationInformationMutex.RUnlock()
	fake.setRefreshTokenMutex.RLock()
	defer fake.setRefreshTokenMutex.RUnlock()
	fake.setSpaceInformationMutex.RLock()
	defer fake.setSpaceInformationMutex.RUnlock()
	fake.setTargetInformationMutex.RLock()
	defer fake.setTargetInformationMutex.RUnlock()
	fake.setTokenInformationMutex.RLock()
	defer fake.setTokenInformationMutex.RUnlock()
	fake.setUAAEndpointMutex.RLock()
	defer fake.setUAAEndpointMutex.RUnlock()
	fake.skipSSLValidationMutex.RLock()
	defer fake.skipSSLValidationMutex.RUnlock()
	fake.sSHOAuthClientMutex.RLock()
	defer fake.sSHOAuthClientMutex.RUnlock()
	fake.stagingTimeoutMutex.RLock()
	defer fake.stagingTimeoutMutex.RUnlock()
	fake.startupTimeoutMutex.RLock()
	defer fake.startupTimeoutMutex.RUnlock()
	fake.targetMutex.RLock()
	defer fake.targetMutex.RUnlock()
	fake.targetedOrganizationMutex.RLock()
	defer fake.targetedOrganizationMutex.RUnlock()
	fake.targetedSpaceMutex.RLock()
	defer fake.targetedSpaceMutex.RUnlock()
	fake.uAAOAuthClientMutex.RLock()
	defer fake.uAAOAuthClientMutex.RUnlock()
	fake.uAAOAuthClientSecretMutex.RLock()
	defer fake.uAAOAuthClientSecretMutex.RUnlock()
	fake.unsetOrganizationInformationMutex.RLock()
	defer fake.unsetOrganizationInformationMutex.RUnlock()
	fake.unsetSpaceInformationMutex.RLock()
	defer fake.unsetSpaceInformationMutex.RUnlock()
	fake.verboseMutex.RLock()
	defer fake.verboseMutex.RUnlock()
	fake.writePluginConfigMutex.RLock()
	defer fake.writePluginConfigMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ command.Config = new(FakeConfig)
